/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AdvancedConfigurationObservation struct {
	DefaultReadConcern *string `json:"defaultReadConcern,omitempty" tf:"default_read_concern,omitempty"`

	DefaultWriteConcern *string `json:"defaultWriteConcern,omitempty" tf:"default_write_concern,omitempty"`

	FailIndexKeyTooLong *bool `json:"failIndexKeyTooLong,omitempty" tf:"fail_index_key_too_long,omitempty"`

	JavascriptEnabled *bool `json:"javascriptEnabled,omitempty" tf:"javascript_enabled,omitempty"`

	MinimumEnabledTLSProtocol *string `json:"minimumEnabledTlsProtocol,omitempty" tf:"minimum_enabled_tls_protocol,omitempty"`

	NoTableScan *bool `json:"noTableScan,omitempty" tf:"no_table_scan,omitempty"`

	OplogMinRetentionHours *float64 `json:"oplogMinRetentionHours,omitempty" tf:"oplog_min_retention_hours,omitempty"`

	OplogSizeMb *float64 `json:"oplogSizeMb,omitempty" tf:"oplog_size_mb,omitempty"`

	SampleRefreshIntervalBiConnector *float64 `json:"sampleRefreshIntervalBiConnector,omitempty" tf:"sample_refresh_interval_bi_connector,omitempty"`

	SampleSizeBiConnector *float64 `json:"sampleSizeBiConnector,omitempty" tf:"sample_size_bi_connector,omitempty"`
}

type AdvancedConfigurationParameters struct {

	// +kubebuilder:validation:Optional
	DefaultReadConcern *string `json:"defaultReadConcern,omitempty" tf:"default_read_concern,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultWriteConcern *string `json:"defaultWriteConcern,omitempty" tf:"default_write_concern,omitempty"`

	// +kubebuilder:validation:Optional
	FailIndexKeyTooLong *bool `json:"failIndexKeyTooLong,omitempty" tf:"fail_index_key_too_long,omitempty"`

	// +kubebuilder:validation:Optional
	JavascriptEnabled *bool `json:"javascriptEnabled,omitempty" tf:"javascript_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	MinimumEnabledTLSProtocol *string `json:"minimumEnabledTlsProtocol,omitempty" tf:"minimum_enabled_tls_protocol,omitempty"`

	// +kubebuilder:validation:Optional
	NoTableScan *bool `json:"noTableScan,omitempty" tf:"no_table_scan,omitempty"`

	// +kubebuilder:validation:Optional
	OplogMinRetentionHours *float64 `json:"oplogMinRetentionHours,omitempty" tf:"oplog_min_retention_hours,omitempty"`

	// +kubebuilder:validation:Optional
	OplogSizeMb *float64 `json:"oplogSizeMb,omitempty" tf:"oplog_size_mb,omitempty"`

	// +kubebuilder:validation:Optional
	SampleRefreshIntervalBiConnector *float64 `json:"sampleRefreshIntervalBiConnector,omitempty" tf:"sample_refresh_interval_bi_connector,omitempty"`

	// +kubebuilder:validation:Optional
	SampleSizeBiConnector *float64 `json:"sampleSizeBiConnector,omitempty" tf:"sample_size_bi_connector,omitempty"`
}

type AnalyticsAutoScalingObservation struct {
	ComputeEnabled *bool `json:"computeEnabled,omitempty" tf:"compute_enabled,omitempty"`

	ComputeMaxInstanceSize *string `json:"computeMaxInstanceSize,omitempty" tf:"compute_max_instance_size,omitempty"`

	ComputeMinInstanceSize *string `json:"computeMinInstanceSize,omitempty" tf:"compute_min_instance_size,omitempty"`

	ComputeScaleDownEnabled *bool `json:"computeScaleDownEnabled,omitempty" tf:"compute_scale_down_enabled,omitempty"`

	DiskGbEnabled *bool `json:"diskGbEnabled,omitempty" tf:"disk_gb_enabled,omitempty"`
}

type AnalyticsAutoScalingParameters struct {

	// +kubebuilder:validation:Optional
	ComputeEnabled *bool `json:"computeEnabled,omitempty" tf:"compute_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ComputeMaxInstanceSize *string `json:"computeMaxInstanceSize,omitempty" tf:"compute_max_instance_size,omitempty"`

	// +kubebuilder:validation:Optional
	ComputeMinInstanceSize *string `json:"computeMinInstanceSize,omitempty" tf:"compute_min_instance_size,omitempty"`

	// +kubebuilder:validation:Optional
	ComputeScaleDownEnabled *bool `json:"computeScaleDownEnabled,omitempty" tf:"compute_scale_down_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	DiskGbEnabled *bool `json:"diskGbEnabled,omitempty" tf:"disk_gb_enabled,omitempty"`
}

type AnalyticsSpecsObservation struct {
	DiskIops *float64 `json:"diskIops,omitempty" tf:"disk_iops,omitempty"`

	EBSVolumeType *string `json:"ebsVolumeType,omitempty" tf:"ebs_volume_type,omitempty"`

	InstanceSize *string `json:"instanceSize,omitempty" tf:"instance_size,omitempty"`

	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`
}

type AnalyticsSpecsParameters struct {

	// +kubebuilder:validation:Optional
	DiskIops *float64 `json:"diskIops,omitempty" tf:"disk_iops,omitempty"`

	// +kubebuilder:validation:Optional
	EBSVolumeType *string `json:"ebsVolumeType,omitempty" tf:"ebs_volume_type,omitempty"`

	// +kubebuilder:validation:Required
	InstanceSize *string `json:"instanceSize" tf:"instance_size,omitempty"`

	// +kubebuilder:validation:Optional
	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`
}

type AutoScalingObservation struct {
	ComputeEnabled *bool `json:"computeEnabled,omitempty" tf:"compute_enabled,omitempty"`

	ComputeMaxInstanceSize *string `json:"computeMaxInstanceSize,omitempty" tf:"compute_max_instance_size,omitempty"`

	ComputeMinInstanceSize *string `json:"computeMinInstanceSize,omitempty" tf:"compute_min_instance_size,omitempty"`

	ComputeScaleDownEnabled *bool `json:"computeScaleDownEnabled,omitempty" tf:"compute_scale_down_enabled,omitempty"`

	DiskGbEnabled *bool `json:"diskGbEnabled,omitempty" tf:"disk_gb_enabled,omitempty"`
}

type AutoScalingParameters struct {

	// +kubebuilder:validation:Optional
	ComputeEnabled *bool `json:"computeEnabled,omitempty" tf:"compute_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ComputeMaxInstanceSize *string `json:"computeMaxInstanceSize,omitempty" tf:"compute_max_instance_size,omitempty"`

	// +kubebuilder:validation:Optional
	ComputeMinInstanceSize *string `json:"computeMinInstanceSize,omitempty" tf:"compute_min_instance_size,omitempty"`

	// +kubebuilder:validation:Optional
	ComputeScaleDownEnabled *bool `json:"computeScaleDownEnabled,omitempty" tf:"compute_scale_down_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	DiskGbEnabled *bool `json:"diskGbEnabled,omitempty" tf:"disk_gb_enabled,omitempty"`
}

type BiConnectorConfigObservation struct {
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	ReadPreference *string `json:"readPreference,omitempty" tf:"read_preference,omitempty"`
}

type BiConnectorConfigParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ReadPreference *string `json:"readPreference,omitempty" tf:"read_preference,omitempty"`
}

type BiConnectorObservation struct {
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	ReadPreference *string `json:"readPreference,omitempty" tf:"read_preference,omitempty"`
}

type BiConnectorParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ReadPreference *string `json:"readPreference,omitempty" tf:"read_preference,omitempty"`
}

type ClusterObservation struct {
	AdvancedConfiguration []AdvancedConfigurationObservation `json:"advancedConfiguration,omitempty" tf:"advanced_configuration,omitempty"`

	BackupEnabled *bool `json:"backupEnabled,omitempty" tf:"backup_enabled,omitempty"`

	BiConnector []BiConnectorObservation `json:"biConnector,omitempty" tf:"bi_connector,omitempty"`

	BiConnectorConfig []BiConnectorConfigObservation `json:"biConnectorConfig,omitempty" tf:"bi_connector_config,omitempty"`

	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	ClusterType *string `json:"clusterType,omitempty" tf:"cluster_type,omitempty"`

	ConnectionStrings []ConnectionStringsObservation `json:"connectionStrings,omitempty" tf:"connection_strings,omitempty"`

	CreateDate *string `json:"createDate,omitempty" tf:"create_date,omitempty"`

	DiskSizeGb *float64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb,omitempty"`

	EncryptionAtRestProvider *string `json:"encryptionAtRestProvider,omitempty" tf:"encryption_at_rest_provider,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Labels []LabelsObservation `json:"labels,omitempty" tf:"labels,omitempty"`

	MongoDBMajorVersion *string `json:"mongoDbMajorVersion,omitempty" tf:"mongo_db_major_version,omitempty"`

	MongoDBVersion *string `json:"mongoDbVersion,omitempty" tf:"mongo_db_version,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Paused *bool `json:"paused,omitempty" tf:"paused,omitempty"`

	PitEnabled *bool `json:"pitEnabled,omitempty" tf:"pit_enabled,omitempty"`

	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	ReplicationSpecs []ReplicationSpecsObservation `json:"replicationSpecs,omitempty" tf:"replication_specs,omitempty"`

	RootCertType *string `json:"rootCertType,omitempty" tf:"root_cert_type,omitempty"`

	StateName *string `json:"stateName,omitempty" tf:"state_name,omitempty"`

	TerminationProtectionEnabled *bool `json:"terminationProtectionEnabled,omitempty" tf:"termination_protection_enabled,omitempty"`

	VersionReleaseSystem *string `json:"versionReleaseSystem,omitempty" tf:"version_release_system,omitempty"`
}

type ClusterParameters struct {

	// +kubebuilder:validation:Optional
	AdvancedConfiguration []AdvancedConfigurationParameters `json:"advancedConfiguration,omitempty" tf:"advanced_configuration,omitempty"`

	// +kubebuilder:validation:Optional
	BackupEnabled *bool `json:"backupEnabled,omitempty" tf:"backup_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	BiConnector []BiConnectorParameters `json:"biConnector,omitempty" tf:"bi_connector,omitempty"`

	// +kubebuilder:validation:Optional
	BiConnectorConfig []BiConnectorConfigParameters `json:"biConnectorConfig,omitempty" tf:"bi_connector_config,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterType *string `json:"clusterType,omitempty" tf:"cluster_type,omitempty"`

	// +kubebuilder:validation:Optional
	DiskSizeGb *float64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb,omitempty"`

	// +kubebuilder:validation:Optional
	EncryptionAtRestProvider *string `json:"encryptionAtRestProvider,omitempty" tf:"encryption_at_rest_provider,omitempty"`

	// +kubebuilder:validation:Optional
	Labels []LabelsParameters `json:"labels,omitempty" tf:"labels,omitempty"`

	// +kubebuilder:validation:Optional
	MongoDBMajorVersion *string `json:"mongoDbMajorVersion,omitempty" tf:"mongo_db_major_version,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Paused *bool `json:"paused,omitempty" tf:"paused,omitempty"`

	// +kubebuilder:validation:Optional
	PitEnabled *bool `json:"pitEnabled,omitempty" tf:"pit_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// +kubebuilder:validation:Optional
	ReplicationSpecs []ReplicationSpecsParameters `json:"replicationSpecs,omitempty" tf:"replication_specs,omitempty"`

	// +kubebuilder:validation:Optional
	RootCertType *string `json:"rootCertType,omitempty" tf:"root_cert_type,omitempty"`

	// +kubebuilder:validation:Optional
	TerminationProtectionEnabled *bool `json:"terminationProtectionEnabled,omitempty" tf:"termination_protection_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	VersionReleaseSystem *string `json:"versionReleaseSystem,omitempty" tf:"version_release_system,omitempty"`
}

type ConnectionStringsObservation struct {
	AwsPrivateLink map[string]*string `json:"awsPrivateLink,omitempty" tf:"aws_private_link,omitempty"`

	AwsPrivateLinkSrv map[string]*string `json:"awsPrivateLinkSrv,omitempty" tf:"aws_private_link_srv,omitempty"`

	Private *string `json:"private,omitempty" tf:"private,omitempty"`

	PrivateEndpoint []PrivateEndpointObservation `json:"privateEndpoint,omitempty" tf:"private_endpoint,omitempty"`

	PrivateSrv *string `json:"privateSrv,omitempty" tf:"private_srv,omitempty"`

	Standard *string `json:"standard,omitempty" tf:"standard,omitempty"`

	StandardSrv *string `json:"standardSrv,omitempty" tf:"standard_srv,omitempty"`
}

type ConnectionStringsParameters struct {
}

type ElectableSpecsObservation struct {
	DiskIops *float64 `json:"diskIops,omitempty" tf:"disk_iops,omitempty"`

	EBSVolumeType *string `json:"ebsVolumeType,omitempty" tf:"ebs_volume_type,omitempty"`

	InstanceSize *string `json:"instanceSize,omitempty" tf:"instance_size,omitempty"`

	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`
}

type ElectableSpecsParameters struct {

	// +kubebuilder:validation:Optional
	DiskIops *float64 `json:"diskIops,omitempty" tf:"disk_iops,omitempty"`

	// +kubebuilder:validation:Optional
	EBSVolumeType *string `json:"ebsVolumeType,omitempty" tf:"ebs_volume_type,omitempty"`

	// +kubebuilder:validation:Required
	InstanceSize *string `json:"instanceSize" tf:"instance_size,omitempty"`

	// +kubebuilder:validation:Optional
	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`
}

type EndpointsObservation struct {
	EndpointID *string `json:"endpointId,omitempty" tf:"endpoint_id,omitempty"`

	ProviderName *string `json:"providerName,omitempty" tf:"provider_name,omitempty"`

	Region *string `json:"region,omitempty" tf:"region,omitempty"`
}

type EndpointsParameters struct {
}

type LabelsObservation struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type LabelsParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PrivateEndpointObservation struct {
	ConnectionString *string `json:"connectionString,omitempty" tf:"connection_string,omitempty"`

	Endpoints []EndpointsObservation `json:"endpoints,omitempty" tf:"endpoints,omitempty"`

	SrvConnectionString *string `json:"srvConnectionString,omitempty" tf:"srv_connection_string,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type PrivateEndpointParameters struct {
}

type ReadOnlySpecsObservation struct {
	DiskIops *float64 `json:"diskIops,omitempty" tf:"disk_iops,omitempty"`

	EBSVolumeType *string `json:"ebsVolumeType,omitempty" tf:"ebs_volume_type,omitempty"`

	InstanceSize *string `json:"instanceSize,omitempty" tf:"instance_size,omitempty"`

	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`
}

type ReadOnlySpecsParameters struct {

	// +kubebuilder:validation:Optional
	DiskIops *float64 `json:"diskIops,omitempty" tf:"disk_iops,omitempty"`

	// +kubebuilder:validation:Optional
	EBSVolumeType *string `json:"ebsVolumeType,omitempty" tf:"ebs_volume_type,omitempty"`

	// +kubebuilder:validation:Required
	InstanceSize *string `json:"instanceSize" tf:"instance_size,omitempty"`

	// +kubebuilder:validation:Optional
	NodeCount *float64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`
}

type RegionConfigsObservation struct {
	AnalyticsAutoScaling []AnalyticsAutoScalingObservation `json:"analyticsAutoScaling,omitempty" tf:"analytics_auto_scaling,omitempty"`

	AnalyticsSpecs []AnalyticsSpecsObservation `json:"analyticsSpecs,omitempty" tf:"analytics_specs,omitempty"`

	AutoScaling []AutoScalingObservation `json:"autoScaling,omitempty" tf:"auto_scaling,omitempty"`

	BackingProviderName *string `json:"backingProviderName,omitempty" tf:"backing_provider_name,omitempty"`

	ElectableSpecs []ElectableSpecsObservation `json:"electableSpecs,omitempty" tf:"electable_specs,omitempty"`

	Priority *float64 `json:"priority,omitempty" tf:"priority,omitempty"`

	ProviderName *string `json:"providerName,omitempty" tf:"provider_name,omitempty"`

	ReadOnlySpecs []ReadOnlySpecsObservation `json:"readOnlySpecs,omitempty" tf:"read_only_specs,omitempty"`

	RegionName *string `json:"regionName,omitempty" tf:"region_name,omitempty"`
}

type RegionConfigsParameters struct {

	// +kubebuilder:validation:Optional
	AnalyticsAutoScaling []AnalyticsAutoScalingParameters `json:"analyticsAutoScaling,omitempty" tf:"analytics_auto_scaling,omitempty"`

	// +kubebuilder:validation:Optional
	AnalyticsSpecs []AnalyticsSpecsParameters `json:"analyticsSpecs,omitempty" tf:"analytics_specs,omitempty"`

	// +kubebuilder:validation:Optional
	AutoScaling []AutoScalingParameters `json:"autoScaling,omitempty" tf:"auto_scaling,omitempty"`

	// +kubebuilder:validation:Optional
	BackingProviderName *string `json:"backingProviderName,omitempty" tf:"backing_provider_name,omitempty"`

	// +kubebuilder:validation:Optional
	ElectableSpecs []ElectableSpecsParameters `json:"electableSpecs,omitempty" tf:"electable_specs,omitempty"`

	// +kubebuilder:validation:Required
	Priority *float64 `json:"priority" tf:"priority,omitempty"`

	// +kubebuilder:validation:Required
	ProviderName *string `json:"providerName" tf:"provider_name,omitempty"`

	// +kubebuilder:validation:Optional
	ReadOnlySpecs []ReadOnlySpecsParameters `json:"readOnlySpecs,omitempty" tf:"read_only_specs,omitempty"`

	// +kubebuilder:validation:Required
	RegionName *string `json:"regionName" tf:"region_name,omitempty"`
}

type ReplicationSpecsObservation struct {
	ContainerID map[string]*string `json:"containerId,omitempty" tf:"container_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	NumShards *float64 `json:"numShards,omitempty" tf:"num_shards,omitempty"`

	RegionConfigs []RegionConfigsObservation `json:"regionConfigs,omitempty" tf:"region_configs,omitempty"`

	ZoneName *string `json:"zoneName,omitempty" tf:"zone_name,omitempty"`
}

type ReplicationSpecsParameters struct {

	// +kubebuilder:validation:Optional
	NumShards *float64 `json:"numShards,omitempty" tf:"num_shards,omitempty"`

	// +kubebuilder:validation:Required
	RegionConfigs []RegionConfigsParameters `json:"regionConfigs" tf:"region_configs,omitempty"`

	// +kubebuilder:validation:Optional
	ZoneName *string `json:"zoneName,omitempty" tf:"zone_name,omitempty"`
}

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterParameters `json:"forProvider"`
}

// ClusterStatus defines the observed state of Cluster.
type ClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Cluster is the Schema for the Clusters API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,mongodb}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.clusterType)",message="clusterType is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.name)",message="name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.projectId)",message="projectId is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.replicationSpecs)",message="replicationSpecs is a required parameter"
	Spec   ClusterSpec   `json:"spec"`
	Status ClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterList contains a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// Repository type metadata.
var (
	Cluster_Kind             = "Cluster"
	Cluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Cluster_Kind}.String()
	Cluster_KindAPIVersion   = Cluster_Kind + "." + CRDGroupVersion.String()
	Cluster_GroupVersionKind = CRDGroupVersion.WithKind(Cluster_Kind)
)

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
